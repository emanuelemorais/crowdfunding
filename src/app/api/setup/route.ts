import { NextResponse } from 'next/server';
import xrpl from 'xrpl';
import { neon } from '@neondatabase/serverless';
import { loadState, PocState, CurrencyInfo } from '../common/utils';
import { createFundedWallet, waitForAccountActivated, submitTx, sleep, setTrustLine } from '../common/utils';

async function issueTokens(
  client: xrpl.Client,
  issuer: xrpl.Wallet,
  destination: string,
  currency: string,
  value: string
) {
  const tx: xrpl.Payment = {
    TransactionType: 'Payment',
    Account: issuer.address,
    Destination: destination,
    Amount: {
      currency,
      issuer: issuer.address,
      value
    }
  };
  const prepared = await client.autofill(tx);
  const signed = issuer.sign(prepared);
  await client.submitAndWait(signed.tx_blob);
}

export async function GET() {
  const existing = await loadState();
  if (existing) {
    return NextResponse.json(existing, { status: 200 });
  }

  const client = new xrpl.Client('wss://s.altnet.rippletest.net:51233');
  await client.connect();
  try {
    const sql = neon(process.env.DATABASE_URL as string);
    const admin = await createFundedWallet(client);
    const inv1 = await createFundedWallet(client);
    const inv2 = await createFundedWallet(client);
    const inv3 = await createFundedWallet(client);

    await waitForAccountActivated(client, admin.address);
    await waitForAccountActivated(client, inv1.address);
    await waitForAccountActivated(client, inv2.address);
    await waitForAccountActivated(client, inv3.address);

    await submitTx(client, admin, {
      TransactionType: "AccountSet",
      Account: admin.address,
      SetFlag: xrpl.AccountSetAsfFlags.asfDefaultRipple 
    });

    await sleep(200);

    await submitTx(client, admin, {
      TransactionType: "AccountSet",
      Account: admin.address,
      SetFlag: xrpl.AccountSetAsfFlags.asfRequireAuth 
    });


    await sleep(300);

    const codes = ['BRL', 'TKA', 'TKB'];

    // Trust lines for first two investors for all codes
    for (const investor of [inv1, inv2]) {
      for (const cur of codes) {
        await setTrustLine(client, investor, admin, cur, '1000000');
        await new Promise(r => setTimeout(r, 500));
      }
    }

    // Third investor: trustline only for BRL
    await setTrustLine(client, inv3, admin, 'BRL', '1000000');
    await new Promise(r => setTimeout(r, 500));

    // Distribute tokens from issuer/admin to first two investors only
    for (const [idx, investor] of [inv1, inv2].entries()) {
      const base = (idx + 1) * 1000;
      for (const cur of codes) {
        await issueTokens(client, admin, investor.address, cur, String(base));
        await new Promise(r => setTimeout(r, 500));
      }
    }

    const currencies: CurrencyInfo[] = codes.map(code => ({
      code,
      link: `${code}:${admin.address}`
    }));

    // Persist to Postgres (Neon)
    // Insert admin and get id
    const adminInserted = await sql`INSERT INTO participants (name, address, secret, role) VALUES (${`Admin`}, ${admin.address}, ${admin.seed ?? ''}, ${`admin`}) RETURNING id`;
    const adminId = (adminInserted as any)[0]?.id as string;

    // Insert investors
    await sql`INSERT INTO participants (name, address, secret, role) VALUES (${`Investor 1`}, ${inv1.address}, ${inv1.seed ?? ''}, ${`investor`})`;
    await sql`INSERT INTO participants (name, address, secret, role) VALUES (${`Investor 2`}, ${inv2.address}, ${inv2.seed ?? ''}, ${`investor`})`;
    await sql`INSERT INTO participants (name, address, secret, role) VALUES (${`Investor 3`}, ${inv3.address}, ${inv3.seed ?? ''}, ${`investor`})`;

    // Insert currencies (link is generated by DB)
    for (const code of codes) {
      await sql`INSERT INTO currencies (code, issuer_participant_id, issuer_address) VALUES (${code}, ${adminId}, ${admin.address}) ON CONFLICT (code, issuer_address) DO NOTHING`;
    }

    const state: PocState = {
      network: 'testnet',
      admin: { address: admin.address, secret: admin.seed ?? '' },
      investors: [
        { name: 'Investor 1', address: inv1.address, secret: inv1.seed ?? '' },
        { name: 'Investor 2', address: inv2.address, secret: inv2.seed ?? '' },
        { name: 'Investor 3', address: inv3.address, secret: inv3.seed ?? '' }
      ],
      currencies,
      distributed: true
    };

    return NextResponse.json(state, { status: 201 });
  } catch (e: any) {
    console.error('XRPL POC setup error:', e);
    return NextResponse.json({ error: 'Failed to setup XRPL POC', details: e?.message ?? String(e) }, { status: 500 });
  } finally {
    client.disconnect();
  }
}

export const runtime = 'nodejs';


